/* 
 * Copyright (C) 2000 Giuseppe Aliberti <giuseppe.aliberti@aquila.infn.it>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


/*   Vel2Grid3D.c

        Modified version of Vel2Grid (by Antony Lomax) to generate a 3-D vel/slowness
        model grid from a 3-D velocity model generated by Simul2k or FDTomo.

 */


/*
        history:

        ver 01    31AUG2000  GA  Original version, supports only Simul2K models
        ver 02    30SEP2000  GA  Added support for FDTomo models
        ver 03    10APR2001  SH  Since I didn't understand the meaning of the
                                 control parameters orig_x, orig_y, and orig_z
                                 I changed the code, so that these parameters are
                                 no longer in use. They should be set to zero in
                                 the control file. Right-handed coord. system
                                 of SIMULPS is transformed in a left-handed
                                 coord. system by multiplying x-pos. of grid
                                 nodes [km] with -1. However, first velocity
                                 grid node of SIMULPS is still in lower left
                                 corner (SE corner). Control parameters
                                 orig_grid_x, orig_grid_y, and orig_grid_z
                                 specify x,y,z location of grid origin
                                 relative to geographic origin (see
                                 Vel2Grid3D control file statements).


.........1.........2.........3.........4.........5.........6.........7.........8

 */



#define PNAME  "Vel2Grid3D"

#include "../src/GridLib.h"
#include "velmod.h"

typedef struct {
    float *buffer; /* buffer (contiguous floats) */
    float ***array; /* array access to buffer */
    int numx; /* Number of nodes in x coord */
    int numy; /* Number of nodes in y coord */
    int numz; /* Number of nodes in z coord */
    double origx; /* X orig (km) */
    double origy; /* Y orig (km) */
    double origz; /* V orig (km) */
    float dx; /* distance of nodes in x coord (km) */
    float dy; /* distance of nodes in y coord (km) */
    float dz; /* distance of nodes in z coord (km) */
    float *deltax; /* array with x coords of nodes (km) */
    float *deltay; /* array with y coords of nodes (km) */
    float *deltaz; /* array with z coords of nodes (km) */
    int type; /* type of velocity model [TYPESIMUL/TYPEFDTOMO] */
} VelModel;

#define TYPESIMUL  0
#define TYPEFDTOMO 1


/* globals  */

char fn_vg_input[MAXLINE];
char fn_vg_output[MAXLINE];


/* wave type (P, S, ...) for vel grids */
#define MAX_NUM_WAVE_TYPES 10
char WaveType[MAX_NUM_WAVE_TYPES][12];
int NumWaveTypes;


/* function declarations */

int ReadVel2Grid3DInput(FILE*, VelModel*);
int ReadVelModel(VelModel*);
int VelModToGrid3d(VelModel*, GridDesc*, char *);
int AllocateVelModel(VelModel*);
void FreeVelModel(VelModel*);

/*** program to generate  3-D vel/slowness grid */


#define NARGS 2
#define LENDELTA 6
#define LENVEL 5

main(int argc, char *argv[]) {

    int istat;
    int nWaveType;
    char fileRoot[MAXLINE];

    GridDesc mod_grid; /* model grid */
    VelModel vel_model; /* Velocity model */



    vel_model.buffer = NULL;
    vel_model.array = NULL;
    vel_model.deltax = vel_model.deltay = vel_model.deltaz = NULL;


    /* set program name */
    strcpy(prog_name, PNAME);

    /* check command line for correct usage */

    if (argc != NARGS) {
        disp_usage(prog_name, "<control file>");
        exit(EXIT_ERROR_USAGE);
    }



    /* set constants */

    prog_mode_3d = 1;
    prog_mode_Mod2D3D = 0;
    NumWaveTypes = 0;
    SetConstants();


    /* read control file */

    strcpy(fn_control, argv[1]);
    if ((fp_control = fopen(fn_control, "r")) == NULL) {
        nll_puterr("ERROR: opening control file.");
        exit(EXIT_ERROR_FILEIO);
    }

    if ((istat = ReadVel2Grid3DInput(fp_control, &vel_model)) < 0) {
        exit(EXIT_ERROR_FILEIO);
    }
    mod_grid = grid_in;


    /* determine model coordinates mode - rect or latlon */
    SetModelCoordsMode(num_surfaces);


    /* read Velocity Model input file */

    if ((istat = ReadVelModel(&vel_model)) < 0) {
        if (istat == -1) nll_puterr("ERROR: reading first line of Velocity Model input file.");
        if (istat == -2) nll_puterr("ERROR: allocating memory for Velocity Model input file.");
        if (istat == -3) nll_puterr("ERROR: reading pos. of x-nodes of Velocity Model input file.");
        if (istat == -4) nll_puterr("ERROR: reading pos. of y-nodes of Velocity Model input file.");
        if (istat == -5) nll_puterr("ERROR: reading pos. of z-nodes of Velocity Model input file.");
        if (istat == -6) nll_puterr("ERROR: reading velocities of Velocity Model input file.");
        /*	nll_puterr("ERROR: reading Velocity Model input file."); */
        exit(EXIT_ERROR_FILEIO);
    }

    /* initialize 3D grid */

    /* allocate model grid */
    mod_grid.buffer = AllocateGrid(&mod_grid);
    if (mod_grid.buffer == NULL) {
        nll_puterr("ERROR: allocating memory for 3D slowness grid buffer.");
        exit(EXIT_ERROR_MEMORY);
    }
    /* create array access pointers */
    mod_grid.array = CreateGridArray(&mod_grid);
    if (mod_grid.array == NULL) {
        nll_puterr("ERROR: creating array for accessing 3D vel/slowness grid buffer.");
        exit(EXIT_ERROR_MEMORY);
    }


    /* create model for each wave type */

    for (nWaveType = 0; nWaveType < NumWaveTypes; nWaveType++) {

        sprintf(fileRoot, "%s.mod", WaveType[nWaveType]);
        sprintf(MsgStr, "Creating model grid files: %s.%s.*",
                fn_vg_output, fileRoot);
        nll_putmsg(1, MsgStr);

        /* load vel model to grid */

        if (istat =
                VelModToGrid3d(&vel_model, &mod_grid, WaveType[nWaveType]) < 0) {
            nll_puterr("ERROR: loading velocity model to grid.");
            exit(EXIT_ERROR_MODEL);
        }

        /* save grid to disk */

        if (istat =
                WriteGrid3dBuf(&mod_grid, NULL, fn_vg_output, fileRoot)
                < 0) {
            nll_puterr("ERROR: writing slowness grid to disk.");
            exit(EXIT_ERROR_IO);
        }

    }


    FreeVelModel(&vel_model);
    exit(EXIT_NORMAL);

}

/*** function to read Velocity Model input file */

int ReadVelModel(VelModel* vel_model) {
    int i, j, k, l;
    int istat, iscan, numwaves;
    float unit, tempfloat;
    char line[4 * MAXLINE], tmpstr[16], *fgets_return;
    FILE* inpfile;


    if ((inpfile = fopen(fn_vg_input, "r")) == NULL) {
        nll_puterr("ERROR: opening Velocity Model input file.");
        return (-1);
    }

    if (vel_model->type == TYPEFDTOMO) {
        if (AllocateVelModel(vel_model) < 0) {
            fclose(inpfile);
            return (-2);
        }

        for (i = 0; i < vel_model->numx; i++)
            vel_model->deltax[i] = vel_model->origx + i * vel_model->dx;
        for (j = 0; j < vel_model->numy; j++)
            vel_model->deltay[j] = vel_model->origy + j * vel_model->dy;
        for (k = 0; k < vel_model->numz; k++)
            vel_model->deltaz[k] = vel_model->origz + k * vel_model->dz;

        for (k = 0; k < vel_model->numz; k++) {
            for (j = 0; j < vel_model->numy; j++) {
                for (i = 0; i < vel_model->numx; i++)
                    fread(&vel_model->array[i][j][k], sizeof (float), 1, inpfile);
            }
        }
    } else {
        if ((fgets(line, 2 * MAXLINE, inpfile)) &&
                (sscanf(line, "%f %d %d %d %d", &unit, &vel_model->numx, &vel_model->numy, &vel_model->numz, &numwaves) == 5)) {
            fprintf(stderr, "\nReadVelModel: no. grid nodes in x,y,z -> %d %d %d \n", vel_model->numx, vel_model->numy, vel_model->numz);
            if (AllocateVelModel(vel_model) < 0) {
                fclose(inpfile);
                return (-2);
            }
            if ((fgets(line, 4 * MAXLINE, inpfile)) && (strlen(line) >= (LENDELTA * vel_model->numx))) {
                fprintf(stderr, "ReaDVelModel: grid nodes in x-dir\n\t");
                for (i = 0; i < vel_model->numx; i++) {
                    sscanf(line + i*LENDELTA, "%f", &tempfloat);
                    fprintf(stderr, " %5.1f ", tempfloat);
                    /*  vel_model->deltax[i]=vel_model->origx+unit*tempfloat; */
                    vel_model->deltax[i] = -unit*tempfloat;
                }
                fprintf(stderr, "\n");
            } else {
                fclose(inpfile);
                return (-3);
            }

            if ((fgets(line, 4 * MAXLINE, inpfile)) && (strlen(line) >= (LENDELTA * vel_model->numy))) {
                fprintf(stderr, "ReaDVelModel: grid nodes in y-dir\n\t");
                for (i = 0; i < vel_model->numy; i++) {
                    sscanf(line + i*LENDELTA, "%f", &tempfloat);
                    /* vel_model->deltay[i]=vel_model->origy+unit*tempfloat; */
                    fprintf(stderr, " %5.1f ", tempfloat);
                    vel_model->deltay[i] = unit*tempfloat;
                    /* fprintf(stderr,"%f\n",vel_model->deltay[i]);  */
                }
                fprintf(stderr, "\n");
            } else {
                fclose(inpfile);
                return (-4);
            }

            if ((fgets(line, 4 * MAXLINE, inpfile)) && (strlen(line) >= (LENDELTA * vel_model->numz))) {
                fprintf(stderr, "ReaDVelModel: grid nodes in z-dir\n\t");
                for (i = 0; i < vel_model->numz; i++) {
                    sscanf(line + i*LENDELTA, "%f", &tempfloat);
                    /* vel_model->deltaz[i]=vel_model->origz+unit*tempfloat; */
                    fprintf(stderr, " %5.1f ", tempfloat);
                    vel_model->deltaz[i] = unit*tempfloat;
                    /* fprintf(stderr,"%f\n",vel_model->deltaz[i]); */
                }
                fprintf(stderr, "\n");
            } else {
                fclose(inpfile);
                return (-5);
            }

            fgets(line, 4 * MAXLINE, inpfile);

            for (k = 0; k < vel_model->numz; k++) {
                /*  	for(j=vel_model->numy;j>0;j--) */
                for (j = 0; j < vel_model->numy; j++) {
                    if ((fgets(line, 2 * MAXLINE, inpfile)) && (strlen(line) >= (LENVEL * vel_model->numx))) {
                        for (i = 0; i < vel_model->numx; i++)
                            sscanf(line + i * LENVEL, "%f", &vel_model->array[i][j][k]);
                    } else {
                        fclose(inpfile);
                        return (-6);
                    }
                }
            }
        } else {
            fclose(inpfile);
            return (-1);
        }
    }

    fclose(inpfile);
    return (0);
}

/*** function to read input file */

int ReadVel2Grid3DInput(FILE* fp_input, VelModel* vel_model) {
    int istat, iscan;
    char param[MAXLINE], *pchr;
    char line[2 * MAXLINE], *fgets_return;

    int flag_control = 0, flag_inpfile = 0, flag_outfile = 0, flag_grid = 0, flag_type = 0,
            flag_trans = 0;
    int flag_include = 1;

    /*	vel_model->origx = vel_model->origy = vel_model->origz = 0; */

    /* read each input line */


    while ((fgets_return = fgets(line, 2 * MAXLINE, fp_input)) != NULL
            || fp_include != NULL) {


        /* check for end of include file */

        if (fgets_return == NULL && fp_include != NULL) {
            SwapBackIncludeFP(&fp_input);
            continue;
        }


        istat = -1;

        /*read parmeter line */

        if ((iscan = sscanf(line, "%s", param)) < 0)
            continue;

        /* skip comment line or white space */

        if (strncmp(param, "#", 1) == 0 || isspace(param[0]))
            istat = 0;



        /* read include file params and set input to include file */

        if (strcmp(param, "INCLUDE") == 0)
            if ((istat = GetIncludeFile(strchr(line, ' '),
                    &fp_input)) < 0) {
                nll_puterr("ERROR: processing include file.");
                flag_include = 0;
            }


        /* read control params */

        if (strcmp(param, "CONTROL") == 0)
            if ((istat = get_control(strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading control params.");
            else
                flag_control = 1;


        /*read transform params */

        if (strcmp(param, "TRANS") == 0)
            /* sh 07/16/03 error in call of get_transform
                                    if ((istat = get_transform(strchr(line, ' '))) < 0) */
            if ((istat = get_transform(0, strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading transformation parameters.");
            else
                flag_trans = 1;


        /* read Input file name (INPfile) */

        if (strcmp(param, "VGINP") == 0)
            if ((istat = get_vg_inpfile(vel_model, strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading 3D Velocity input parameters.");
            else
                flag_inpfile = 1;


        /* read output file name (OUTfile) */

        if (strcmp(param, "VGOUT") == 0)
            if ((istat = get_vg_outfile(strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading Vel2Grid3D output file name.");
            else
                flag_outfile = 1;


        /* read grid params */

        if (strcmp(param, "VGGRID") == 0)
            if ((istat = get_grid(strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading grid parameters.");
            else
                flag_grid = 1;



        /* read grid type (VGTYPE) */

        if (strcmp(param, "VGTYPE") == 0)
            if ((istat = get_vg_type(strchr(line, ' '))) < 0)
                nll_puterr("ERROR: reading Vel2Grid3D grid type.");
            else
                flag_type = 1;



        /* unrecognized input */

        if (istat < 0) {
            if ((pchr = strchr(line, '\n')) != NULL)
                *pchr = '\0';
            sprintf(MsgStr, "Skipping input: %s", line);
            nll_putmsg(4, MsgStr);
        }

    }



    /* check for missing input */

    if (!flag_control)
        nll_puterr("ERROR: no control (CONTROL) params read.");
    if (!flag_inpfile)
        nll_puterr("ERROR: no inputfile (VGINP) params read.");
    if (!flag_outfile)
        nll_puterr("ERROR: no outputfile (VGOUT) params read.");
    if (!flag_type)
        nll_puterr("ERROR: no type (VGTYPE) params read.");
    if (!flag_grid)
        nll_puterr("ERROR: no grid (VGGRID) params read.");

    if (!flag_trans) {
        sprintf(MsgStr, "INFO: no transformation (TRANS) params read.");
        nll_putmsg(1, MsgStr);
        Hypocenter.comment[0] = '\0';
    }

    return (flag_include * flag_control * flag_inpfile * flag_outfile * flag_grid * flag_type - 1);
}

/*** function to read input file name ***/

int get_vg_inpfile(VelModel* vel_model, char* line1) {
    char type[MAXLINE];
    float dx, dy, dz;

    sscanf(line1, "%s %s", fn_vg_input, type);

    if (strcmp(type, "FDTOMO") == 0) {
        if (sscanf(line1, "%*s %*s %lf %lf %lf %d %d %d %f %f %f", &vel_model->origx, &vel_model->origy, &vel_model->origz,
                &vel_model->numx, &vel_model->numy, &vel_model->numz, &vel_model->dx, &vel_model->dy, &vel_model->dz) != 9) {
            nll_puterr("ERROR: reading FDTOMO 3D Velocity input parameters");
            return (-1);
        }
        vel_model->type = TYPEFDTOMO;
    } else {
        if (sscanf(line1, "%*s %*s %lf %lf %lf", &vel_model->origx, &vel_model->origy, &vel_model->origz) != 3) {
            nll_puterr("ERROR: reading SIMUL2K 3D Velocity input parameters");
            return (-1);
        }
        vel_model->type = TYPESIMUL;
    }

    sprintf(MsgStr, "Vel2Grid3D files:  Input: %s   Type: %s", fn_vg_input, type);
    nll_putmsg(3, MsgStr);

    return (0);
}

/*** function to read output file name ***/

int get_vg_outfile(char* line1) {

    sscanf(line1, "%s", fn_vg_output);

    sprintf(MsgStr, "Vel2Grid3D files:  Output: %s.*",
            fn_vg_output);
    nll_putmsg(3, MsgStr);

    return (0);
}

/*** function to read wave type ***/

int get_vg_type(char* line1) {

    if (NumWaveTypes >= MAX_NUM_WAVE_TYPES) {
        nll_puterr("WARNING: maximum number of wave types reached, ignoring wave type.");
        return (-1);
    }


    sscanf(line1, " %s", WaveType[NumWaveTypes]);

    sprintf(MsgStr, "Vel2Grid3D wave type:  %s", WaveType[NumWaveTypes]);
    nll_putmsg(3, MsgStr);

    NumWaveTypes++;


    return (0);
}

/*** returns the velocity in a definite point of the space ***/

float get3Dvel(VelModel* vel_model, float posx, float posy, float posz) {
    float vel;
    int i, j, k;
    float t, u, v;

    //printf("get3Dvel(vel_model, xval %f, yval %f, zdepth %f\n", posx, posy, posz);

    for (i = 0; (i < vel_model->numx) && (vel_model->deltax[i] > posx); i++);
    for (j = 0; (j < vel_model->numy) && (vel_model->deltay[j] < posy); j++);
    for (k = 0; (k < vel_model->numz) && (vel_model->deltaz[k] < posz); k++);

    if (i == 0) {
        t = 0;
        i++;
    } else if (i == vel_model->numx) {
        t = 1;
        i--;
    } else
        t = (posx - vel_model->deltax[i - 1]) / (vel_model->deltax[i] - vel_model->deltax[i - 1]);

    if (j == 0) {
        u = 0;
        j++;
    } else if (j == vel_model->numy) {
        u = 1;
        j--;
    } else
        u = (posy - vel_model->deltay[j - 1]) / (vel_model->deltay[j] - vel_model->deltay[j - 1]);

    if (k == 0) {
        v = 0;
        k++;
    } else if (k == vel_model->numz) {
        v = 1;
        k--;
    } else
        v = (posz - vel_model->deltaz[k - 1]) / (vel_model->deltaz[k] - vel_model->deltaz[k - 1]);

        //printf("get3Dvel(vel_model, i %d, j %d, k %d, t %f, u %f, v %f\n", i, j, k, t, u, v);

        vel = vel_model->array[i - 1][j - 1][k - 1]*(1 - t)*(1 - u)*(1 - v) +
            vel_model->array[i][j - 1][k - 1]*(t)*(1 - u)*(1 - v) +
            vel_model->array[i][j][k - 1]*(t)*(u)*(1 - v) +
            vel_model->array[i - 1][j][k - 1]*(1 - t)*(u)*(1 - v) +
            vel_model->array[i - 1][j - 1][k]*(1 - t)*(1 - u)*(v) +
            vel_model->array[i][j - 1][k]*(t)*(1 - u)*(v) +
            vel_model->array[i][j][k]*(t)*(u)*(v) +
            vel_model->array[i - 1][j][k]*(1 - t)*(u)*(v);

    return (vel);
}


/*** function to load 3D velocity model to model grid ***/

/*  Notes:  

        (1)	Implicit staggered grids used -
        model space and travel time grid is numx X numy X numz while
        slowness grid is numx-1 X numy-1 X numz-1.
        Slowness values are for mid-points of travel time grid cells,
        i.e. slowness grid is shifted (+dx/2,+dy/2,+dz/2) in space relative to
        travel time grid.

        (2)	Podvin Lecomte FFD uses cubic cells, i.e. dx=dy=dz.

 */

int VelModToGrid3d(VelModel* vel_model, GridDesc* grid, char *waveType) {

    int ix, iy, iz;
    int imodel;
    char cWaveType;
    double xval, yval, xloc, yloc, zdepth;
    double vel, den, vel1;


    /* check wavetype */

    if (strcmp(waveType, "P") == 0)
        cWaveType = 'P';
    else if (strcmp(waveType, "S") == 0)
        cWaveType = 'S';
    else {
        nll_puterr2("ERROR: unrecognized wave type", waveType);
        return (-1);
    }


    /* generate grid values */
    /* Note:  staggered grid assumed, thus vel lookup is shifted +dx/2, etc. */

    xval = grid->origx + grid->dx / 2.0;
    for (ix = 0; ix < grid->numx; ix++) {
        yval = grid->origy + grid->dy / 2.0;
        for (iy = 0; iy < grid->numy; iy++) {
            if (ModelCoordsMode == COORDS_LATLON) {
                /* sh 07/16/03 wrong number of parameters in calling rect2latlon
                                                rect2latlon(xval, yval, &yloc, &xloc);*/
                rect2latlon(0, xval, yval, &yloc, &xloc);
            } else {
                xloc = xval;
                yloc = yval;
            }
            zdepth = grid->origz + grid->dz / 2.0;
            for (iz = 0; iz < grid->numz; iz++) {

                /* check for non-lat/lon and non-layer
                                        vel mod element */
                vel = get3Dvel(vel_model, xval, yval, zdepth);

                if (0 && imodel >= LAYEROFFSET || imodel < 0) {
                    /* check for surface */
                    /*vel1 = get_surface_vel(
                            xloc, yloc, zdepth,
                        cWaveType, model_surface,
                        num_surfaces, &den, 0);
                    vel = vel1 > 0.0 ? vel1 : vel;
                     */
                }

                if (vel < 0.0) {
                    nll_puterr("ERROR: cannot get velocity.");
                    return (-1);
                }

                switch (grid->type) {

                    case GRID_VELOCITY:
                        ((GRID_FLOAT_TYPE ***) grid->array)[ix][iy][iz] = vel;
                        break;

                    case GRID_VELOCITY_METERS:
                        ((GRID_FLOAT_TYPE ***) grid->array)[ix][iy][iz] = 1000.0 * vel;
                        break;

                    case GRID_SLOW_LEN:
                        ((GRID_FLOAT_TYPE ***) grid->array)[ix][iy][iz] = grid->dx / vel;
                        break;

                    case GRID_SLOW2_METERS:
                        ((GRID_FLOAT_TYPE ***) grid->array)[ix][iy][iz] =
                                (1.0e-3 / vel) * (1.0e-3 / vel);
                        break;

                    default:
                        nll_puterr("ERROR: unrecognized grid type.");
                        return (-1);

                }


                zdepth += grid->dz;
            }
            yval += grid->dy;
        }
        xval += grid->dx;
    }


    return (0);

}

int AllocateVelModel(VelModel* vel_model) {
    int ix, iy, numyz;
    float ***garray;


    /* Allocates memory for 3D Velocity Model node distance arrays */

    vel_model->deltax = (float *) malloc((size_t) (vel_model->numx * sizeof (float)));
    vel_model->deltay = (float *) malloc((size_t) (vel_model->numy * sizeof (float)));
    vel_model->deltaz = (float *) malloc((size_t) (vel_model->numz * sizeof (float)));

    if ((vel_model->deltax == NULL) || (vel_model->deltay == NULL) || (vel_model->deltaz == NULL)) {
        nll_puterr("ERROR: allocating memory for 3D Velocity Model node distance arrays.");
        return (-1);
    }
    NumAllocations += 3;



    /* allocate Velocity model buffer */

    vel_model->buffer = (float *) malloc((size_t)
            (vel_model->numx * vel_model->numy * vel_model->numz * sizeof (float)));
    if (vel_model->buffer == NULL) {
        nll_puterr("ERROR: allocating memory for 3D Velocity Model buffer.");
        return (-1);
    }
    NumAllocations++;



    /* creates array for accessing 3D velocity model */

    garray = (float ***) malloc((size_t) vel_model->numx * sizeof (float **));
    if (garray == NULL) {
        nll_puterr("ERROR: creating array for accessing 3D Velocity Model buffer.");
        return (-1);
    }
    NumAllocations++;
    numyz = vel_model->numy * vel_model->numz;
    for (ix = 0; ix < vel_model->numx; ix++) {
        garray[ix] = (float **) malloc((size_t) vel_model->numy * sizeof (float *));
        if (garray[ix] == NULL) {
            nll_puterr("ERROR: creating array for accessing 3D Velocity Model buffer.");
            return (-1);
        }
        NumAllocations++;
        for (iy = 0; iy < vel_model->numy; iy++)
            garray[ix][iy] = vel_model->buffer + ix * numyz + iy * vel_model->numz;
    }
    vel_model->array = garray;
    return (0);
}

/*** function to free the allocations in the velocity model structure ***/
void FreeVelModel(VelModel* vel_model) {
    int ix;

    /*** frees the array for accessing 3D velocity model ***/
    if (vel_model->array) {
        for (ix = 0; ix < vel_model->numx; ix++) {
            free(vel_model->array[ix]);
            NumAllocations--;
        }

        free(vel_model->array);
        NumAllocations--;

        vel_model->array = NULL;
    }


    /*** frees the buffer for 3D velocity model ***/
    if (vel_model->buffer) {
        free(vel_model->buffer);
        NumAllocations--;
        vel_model->buffer = NULL;
    }


    /* frees the arrays for 3D Velocity Model node distance */
    if (vel_model->deltax)
        free(vel_model->deltax);
    if (vel_model->deltay)
        free(vel_model->deltay);
    if (vel_model->deltaz)
        free(vel_model->deltaz);

}

